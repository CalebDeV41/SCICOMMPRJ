<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Embedding Diagram</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://esm.run/three';
    import { OrbitControls } from 'https://esm.run/three/examples/jsm/controls/OrbitControls';
    import GUI from 'https://esm.run/lil-gui';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // Black background

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 50);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const sphereGeom = new THREE.SphereGeometry(1, 64, 64);
    const sphereMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
    sphere.position.set(0, 0, 6);
    scene.add(sphere);

    const params = { R: 6, M: 25 };
    let surfaceMesh, wireMesh;

    function generateSurface(R, M) {
      const geometry = new THREE.PlaneGeometry(350, 350, 175, 175); // high res
      const posAttr = geometry.attributes.position;

      for (let i = 0; i < posAttr.count; i++) {
        const x = posAttr.getX(i);
        const y = posAttr.getY(i);
        const denom = (x**2 + y**2)/(R**2) + 1/(Math.sqrt(M));
        const z = -1 / denom;
        posAttr.setZ(i, z);
      }

      posAttr.needsUpdate = true;
      geometry.computeVertexNormals();

      const shadedMat = new THREE.MeshNormalMaterial({
        side: THREE.DoubleSide,
        flatShading: false,
      });

      const wireMat = new THREE.MeshBasicMaterial({
        color: 0x222222,
        wireframe: true,
        opacity: 0.6,
        transparent: true,
      });

      const surface = new THREE.Mesh(geometry, shadedMat);
      const wire = new THREE.Mesh(geometry, wireMat);
      return { surface, wire };
    }

    function updateSurface() {
      if (surfaceMesh) {
        scene.remove(surfaceMesh);
        surfaceMesh.geometry.dispose();
        surfaceMesh.material.dispose();
      }
      if (wireMesh) {
        scene.remove(wireMesh);
        wireMesh.geometry.dispose();
        wireMesh.material.dispose();
      }

      const { surface, wire } = generateSurface(params.R, params.M);
      surfaceMesh = surface;
      wireMesh = wire;
      scene.add(surfaceMesh);
      scene.add(wireMesh);
      const scaleFactor = Math.log(params.R + 1);
      sphere.scale.set(scaleFactor, scaleFactor, scaleFactor);
    }

    updateSurface();

    const gui = new GUI();
    gui.add(params, 'R', 1, 100).onChange(updateSurface);
    gui.add(params, 'M', 1, 1000).onChange(updateSurface);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
