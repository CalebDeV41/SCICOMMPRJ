<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Embedding Diagram</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://esm.run/three';
    import { OrbitControls } from 'https://esm.run/three/examples/jsm/controls/OrbitControls';
    import GUI from 'https://esm.run/lil-gui';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // Black background

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 50);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const sphereGeom = new THREE.SphereGeometry(1, 64, 64);
    const sphereMat = new THREE.MeshBasicMaterial({color: 0xff0000, roughness: 0.5, metalness: 0.1});
    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
    sphere.position.set(0, 0, 8);
    scene.add(sphere);

    const params = { R: 60, M: 2500 };
    let surfaceMesh, wireMesh;

    function applyCurvature(geometry, R, M) {
  const posAttr = geometry.attributes.position;

  for (let i = 0; i < posAttr.count; i++) {
    const x = posAttr.getX(i);
    const y = posAttr.getY(i);
    const denom = (x**2 + y**2)/(R**2 + Math.sqrt(M)) + (Math.sqrt(R)/M);
    const z = -1 / denom;
    posAttr.setZ(i, z);
  }

  posAttr.needsUpdate = true;
  geometry.computeVertexNormals();
}

// Low-res wireframe geometry for grid overlay
const gridGeometry = new THREE.PlaneGeometry(400, 400, 50, 50);
applyCurvature(gridGeometry, R, M);

// Wireframe material
const wireMat = new THREE.MeshBasicMaterial({
  color: 0x222222,
  wireframe: true,
  opacity: 0.6,
  transparent: true,
});

// Upper wire mesh
const wireAbove = new THREE.Mesh(gridGeometry.clone(), wireMat);
wireAbove.position.z = 0.01;

// Lower wire mesh
const wireBelow = new THREE.Mesh(gridGeometry.clone(), wireMat);
wireBelow.position.z = -0.01;

// Return all 3 meshes
return { surface, wires: [wireAbove, wireBelow] };

function updateSurface() {
  if (surfaceMesh) {
    scene.remove(surfaceMesh);
    surfaceMesh.geometry.dispose();
    surfaceMesh.material.dispose();
  }

  if (wireMesh) {
    for (const mesh of wireMesh) {
      scene.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
    }
  }

  const { surface, wires } = generateSurface(params.R, params.M);
  surfaceMesh = surface;
  wireMesh = wires;

  scene.add(surfaceMesh);
  for (const mesh of wireMesh) scene.add(mesh);

  const scaleFactor = Math.sqrt(params.R + 1);
  sphere.scale.set(scaleFactor, scaleFactor, scaleFactor);
}

    updateSurface();

    const gui = new GUI();
    gui.add(params, 'R', 1, 1000).onChange(updateSurface);
    gui.add(params, 'M', 250, 10000).onChange(updateSurface);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
