<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Relativistic Embedding Diagram</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://esm.run/three';
    import { OrbitControls } from 'https://esm.run/three/examples/jsm/controls/OrbitControls';
    import GUI from 'https://esm.run/lil-gui';

    // Constants in km and Pg units
    const G = 6.67430e-20;      // km³ / (Pg * s²)
    const c = 299792.458;       // km/s

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 500);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const sphereGeom = new THREE.SphereGeometry(1, 64, 64);
    const sphereMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.1 });
    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
    scene.add(sphere);

    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(500, 500, 1000);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    const params = { 
      M: 5.972e9,     // Mass in Pg (Earth mass)
      R_obj: 6371,    // Radius in km (Earth radius)
      scaleZ: 500     // Vertical exaggeration
    };

    let surfaceMesh, wireMesh;

    function generateSurface(M, R_obj, scaleZ) {
      const gridSize = 400;
      const segments = 400;
      const geometry = new THREE.PlaneGeometry(gridSize, gridSize, segments, segments);
      const posAttr = geometry.attributes.position;

      const Rs = (2 * G * M) / (c * c);

      for (let i = 0; i < posAttr.count; i++) {
        const x = posAttr.getX(i);
        const y = posAttr.getY(i);
        const r = Math.sqrt(x * x + y * y);

        let dzdr = 0;

        if (R_obj <= Rs) {
          // Black hole: Only exterior solution starting at Rs
          if (r >= Rs) {
            dzdr = Math.sqrt((2 * G * M) / (c * c * r - 2 * G * M));
          } else {
            dzdr = 0;  // Inside event horizon is undefined, flatten it
          }
        } else {
          if (r >= R_obj) {
            dzdr = Math.sqrt((2 * G * M) / (c * c * r - 2 * G * M));
          } else {
            const interiorTerm = 1 - (2 * G * M * r * r) / (c * c * Math.pow(R_obj, 3));
            dzdr = Math.sqrt(1 / interiorTerm - 1);
          }
        }

        // Approximate integration by summing dzdr * dr
        const z = scaleZ * dzdr;
        posAttr.setZ(i, isFinite(z) ? -z : 0);
      }

      posAttr.needsUpdate = true;
      geometry.computeVertexNormals();

      const shadedMat = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide, flatShading: false });
      const wireMat = new THREE.MeshBasicMaterial({ color: 0x222222, wireframe: true, opacity: 0.6, transparent: true });

      const surface = new THREE.Mesh(geometry, shadedMat);
      const wire = new THREE.Mesh(geometry, wireMat);
      return { surface, wire };
    }

    function updateSurface() {
      if (surfaceMesh) {
        scene.remove(surfaceMesh);
        surfaceMesh.geometry.dispose();
        surfaceMesh.material.dispose();
      }
      if (wireMesh) {
        scene.remove(wireMesh);
        wireMesh.geometry.dispose();
        wireMesh.material.dispose();
      }

      const { surface, wire } = generateSurface(params.M, params.R_obj, params.scaleZ);
      surfaceMesh = surface;
      wireMesh = wire;
      scene.add(surfaceMesh);
      scene.add(wireMesh);

      const Rs = (2 * G * params.M) / (c * c);
      const sphereRadius = (params.R_obj <= Rs) ? Rs : params.R_obj;
      const scaleFactor = sphereRadius / 50;  // Adjust visual scaling
      sphere.scale.set(scaleFactor, scaleFactor, scaleFactor);
    }

    const gui = new GUI();
    gui.add(params, 'M', 1e6, 1e12).name('Mass (Pg)').onChange(updateSurface);
    gui.add(params, 'R_obj', 1, 1e5).name('Radius (km)').onChange(updateSurface);
    gui.add(params, 'scaleZ', 100, 1000).name('Vertical Scale').onChange(updateSurface);

    updateSurface();

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
